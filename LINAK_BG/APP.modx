MODULE APP

    !InitActuator puuttuu
    !Waitforstop puuttuu

    PERS num nCommandCurrent;
    PERS num nCommandSpeed;
    PERS num nCommandPosition;
    PERS num nCommandStartRamp;
    PERS num nCommandStopRamp;
    PERS string sCommandCurrent;
    PERS string sCommandSpeed;
    PERS string sCommandPosition;
    PERS string sCommandStartRamp;
    PERS string sCommandStopRamp;
    VAR num nHi;
    VAR num nLo;
    PERS num nInputCurrent;
    PERS num nInputSpeed;
    PERS num nInputPosition;
    VAR string sInputPosition;
    PERS num nInputStartramp;
    PERS num nInputStopramp;
    PERS num nCurrent;
    PERS num nSpeed;
    PERS num nPosition;
    PERS num nStartramp;
    PERS num nStopramp;


    PROC SetCommandRoutine()
        ConnectToServer;
        Init;
        Heartbeat;
        ReadStatus;
        ConvertInputs;
        SetCommandValues;
        ReadCommandValues;

    ENDPROC

    PROC ReadCommandRoutine()
        ConnectToServer;
        Init;
        Heartbeat;
        ReadStatus;
        ReadCommandValues;

    ENDPROC

    PROC SetCommandValues()
   

        ClearRawBytes raw_data_out;
        PackRawBytes nTFID_Hi,raw_data_out,1\IntX:=USINT;
        !Transaction ID Hi
        PackRawBytes nTFID_Lo,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Transaction ID Lo
        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Protocol ID Hi
        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Protocol ID Lo
        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Message length Hi
        PackRawBytes 15,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Message length Lo (6)
        PackRawBytes nDeviceAdr,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Device address
        PackRawBytes 16,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Functional code (3 = read, 6 = write, 16 = write multiple)
        PackRawBytes 32,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Register/index Hi
        PackRawBytes 3,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Register/index Lo
        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Value (write) / Number of registers (read) Hi
        PackRawBytes 4,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Value (write) / Number of registers (read) Lo
        PackRawBytes 2,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !6


        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        PackRawBytes nCurrent,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;

        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        PackRawBytes nSpeed,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;

        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        PackRawBytes nStartRamp,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;

        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        PackRawBytes nStopRamp,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;

        SocketSend tcp_socket\RawData:=raw_data_out;


        !Receive
        ClearRawBytes raw_data_in;
        SocketReceive tcp_socket\RawData:=raw_data_in;
        UnpackRawBytes raw_data_in,8,nResponse\IntX:=USINT;


        !Check for MODBUS-specific errors
        IF nFunctionCode=nResponse THEN
            !Message OK
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-1,nResponse\IntX:=USINT;
            nServerValue_Hi:=nResponse;
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in),nResponse\IntX:=USINT;
            nServerValue_Lo:=nResponse;

        ELSE
            !Error

            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in),nResponse\IntX:=USINT;
            nErrorCode:=nResponse;
        ENDIF

    ENDPROC





    PROC ReadCommandValues()
        !Read Position, Current, Speed, Soft Start ramp time and Soft Stop ramp time


        !Send
        ClearRawBytes raw_data_out;
        PackRawBytes nTFID_Hi,raw_data_out,1\IntX:=USINT;
        !Transaction ID Hi
        PackRawBytes nTFID_Lo,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Transaction ID Lo
        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Protocol ID Hi
        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Protocol ID Lo
        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Message length Hi
        PackRawBytes 6,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Message length Lo (6)
        PackRawBytes nDeviceAdr,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Device address
        PackRawBytes 3,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Functional code (3 = read, 6 = write)
        PackRawBytes 32,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Register/index Hi
        PackRawBytes 2,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Register/index Lo
        PackRawBytes 0,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Value (write) / Number of registers (read) Hi
        PackRawBytes 5,raw_data_out,(RawBytesLen(raw_data_out)+1)\IntX:=USINT;
        !Value (write) / Number of registers (read) Lo

        SocketSend tcp_socket\RawData:=raw_data_out;


        !Receive
        ClearRawBytes raw_data_in;
        SocketReceive tcp_socket\RawData:=raw_data_in;
        UnpackRawBytes raw_data_in,8,nResponse\IntX:=USINT;


        !Check for MODBUS-specific errors
        IF nResponse=3 THEN
            !Message OK

            !Stop ramp
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-1,nResponse\IntX:=USINT;
            nServerValue_Hi:=nResponse;
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in),nResponse\IntX:=USINT;
            nServerValue_Lo:=nResponse;
            nCommandStopRamp:=256*nServerValue_Hi+nServerValue_Lo;

            IF nCommandStopRamp=251 THEN
                sCommandStopRamp:="Default";
            ELSE
                sCommandStopRamp:=ValToStr(nCommandStopRamp*0.05)+" s";
            ENDIF

            !Start ramp
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-3,nResponse\IntX:=USINT;
            nServerValue_Hi:=nResponse;
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-2,nResponse\IntX:=USINT;
            nServerValue_Lo:=nResponse;
            nCommandStartRamp:=256*nServerValue_Hi+nServerValue_Lo;


            IF nCommandStartRamp=251 THEN
                sCommandStartRamp:="Default";
            ELSE
                sCommandStartRamp:=ValToStr(nCommandStartRamp*0.05)+" s";
            ENDIF


            !Speed
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-5,nResponse\IntX:=USINT;
            nServerValue_Hi:=nResponse;
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-4,nResponse\IntX:=USINT;
            nServerValue_Lo:=nResponse;
            nCommandSpeed:=256*nServerValue_Hi+nServerValue_Lo;

            IF nCommandSpeed=251 THEN
                sCommandSpeed:="Default";
            ELSE
                sCommandSpeed:=ValToStr(nCommandSpeed/2)+" %";
            ENDIF

            !Current limit
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-7,nResponse\IntX:=USINT;
            nServerValue_Hi:=nResponse;
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-6,nResponse\IntX:=USINT;
            nServerValue_Lo:=nResponse;
            nCommandCurrent:=256*nServerValue_Hi+nServerValue_Lo;

            IF nCommandCurrent=251 THEN
                sCommandCurrent:="Default";
            ELSE
                sCommandCurrent:=ValToStr(nCommandCurrent/4)+" A";
            ENDIF


            !Command position
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-9,nResponse\IntX:=USINT;
            nServerValue_Hi:=nResponse;
            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in)-8,nResponse\IntX:=USINT;
            nServerValue_Lo:=nResponse;
            nCommandPosition:=256*nServerValue_Hi+nServerValue_Lo;

            IF nCommandPosition<=64255 THEN
                sCommandPosition:=ValToStr(nCommandPosition/10)+" mm";
            ELSEIF nCommandPosition=64256 THEN
                sCommandPosition:="Clear error register";
            ELSEIF nCommandPosition=64257 THEN
                sCommandPosition:="Run out";
            ELSEIF nCommandPosition=64258 THEN
                sCommandPosition:="Run in";
            ELSEIF nCommandPosition=64259 THEN
                sCommandPosition:="Stop";
            ELSEIF nCommandPosition=64260 THEN
                sCommandPosition:="Recovery run out";
            ELSEIF nCommandPosition=64261 THEN
                sCommandPosition:="Recovery run in";

            ELSE
                sCommandPosition:="Unknown";
            ENDIF




        ELSE
            !Error

            UnpackRawBytes raw_data_in,RawBytesLen(raw_data_in),nResponse\IntX:=USINT;
            nErrorCode:=nResponse;
            ErrWrite "Modbus error","Modbus error: "\RL2:="ReadCommandValues routine";
            Stop;
        ENDIF



    ENDPROC








    PROC SetPositionRoutine()
        Init;
        ConnectToServer;
        Heartbeat;
        ReadStatus;
        sInputPosition:=ValToStr(nInputposition);
        SetPosition sInputPosition;
        ReadCommandValues;
    ENDPROC

    PROC RunInRoutine()
        Init;
        ConnectToServer;
        Heartbeat;
        SetPosition "Run in";
        ReadCommandValues;
    ENDPROC

    PROC RunOutRoutine()
        Init;
        ConnectToServer;
        Heartbeat;
        SetPosition "Run out";
        ReadCommandValues;
    ENDPROC




    PROC ConvertInputs()

        !Current
        IF nInputCurrent=251 THEN
            nCurrent:=251;
        ELSEIF nInputCurrent>=0 AND nInputCurrent<=62.5 THEN
            nCurrent:=Round(nInputCurrent*4);
            !0.25A/bit

        ELSE
            ErrWrite "Invalid value","Invalid value: "\RL2:="Current";
            Stop;
        ENDIF

        !Speed
        IF nInputSpeed=251 THEN
            nSpeed:=251;
        ELSEIF nInputSpeed>=0 AND nInputSpeed<=100 THEN
            nSpeed:=nInputSpeed*2;
            !0.5%/bit
        ELSE
            ErrWrite "Invalid value","Invalid value: "\RL2:="Speed";
            Stop;
        ENDIF

        !Soft Start
        IF nInputStartRamp=251 THEN
            nStartRamp:=251;
        ELSEIF nInputStartRamp>=0 AND nInputStartRamp<=12.5 THEN
            nStartRamp:=Round(nInputStartRamp*20);
            !0.05s/bit
        ELSE
            ErrWrite "Invalid value","Invalid value: "\RL2:="Soft Start Ramping time";
            Stop;
        ENDIF

        !Soft Stop
        IF nInputStopRamp=251 THEN
            nStopRamp:=251;
        ELSEIF nInputStopRamp>=0 AND nInputStopRamp<=12.5 THEN
            nStopRamp:=Round(nInputStopRamp*20);
            !0.05s/bit
        ELSE
            ErrWrite "Invalid value","Invalid value: "\RL2:="Soft Stop Ramping time";
            Stop;
        ENDIF

    ENDPROC






ENDMODULE